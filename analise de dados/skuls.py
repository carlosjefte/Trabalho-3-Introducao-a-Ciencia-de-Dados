# -*- coding: utf-8 -*-
"""skuls.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1GJB-8OtjvEU-53W5uIOeHNqf9sqHWJTa
"""

# esse codifo foi usado para tratar a base de dados

# import pandas as pd
# import numpy as np
# import matplotlib.pyplot as plt
# import seaborn as sns
# file_path = 'Crânios Egípcios.csv'
# df_cleaned = pd.read_csv('Crânios Egípcios.csv', skiprows=1)

# # Rename columns based on the content from the header rows
# df_cleaned.columns = ['Crânios', 'Primitivo_X1', 'Primitivo_X2', 'Primitivo_X3', 'Primitivo_X4',
#                       'Antigo_X1', 'Antigo_X2', 'Antigo_X3', 'Antigo_X4',
#                       'Dinastias_X1', 'Dinastias_X2', 'Dinastias_X3', 'Dinastias_X4',
#                       'Ptolemaico_X1', 'Ptolemaico_X2', 'Ptolemaico_X3', 'Ptolemaico_X4',
#                       'Romano_X1', 'Romano_X2', 'Romano_X3', 'Romano_X4']

# # Initialize lists to hold the data for the new DataFrame
# X1 = []
# X2 = []
# X3 = []
# X4 = []
# labels = []

# # Define the period map
# period_map = {
#     'Primitivo': 'Pré-dinástico primitivo',
#     'Antigo': 'Pré-dinástico antigo',
#     'Dinastias': '12 e 13 dinastias',
#     'Ptolemaico': 'Período ptolemaico',
#     'Romano': 'Período romano'
# }

# # Iterate through each row in the dataframe
# for idx in range(len(df_cleaned)):
#   sample = df_cleaned.iloc[idx]

#   # Iterate through each column and assign values based on the period
#   for period, label in period_map.items():
#       for col in range(1, 5):  # Iterate through X1 to X4
#         col_name = f'{period}_X{col}'
#         if col_name in sample and not pd.isnull(sample[col_name]):
#           if col == 1:
#             X1.append(sample[col_name])
#           elif col == 2:
#             X2.append(sample[col_name])
#           elif col == 3:
#             X3.append(sample[col_name])
#           elif col == 4:
#             X4.append(sample[col_name])
#       labels.append(label)

# # Check that all arrays have the same length
# print(f"X1: {len(X1)}\nX2: {len(X2)}\nX3: {len(X3)}\nX4: {len(X4)}\nLabels: {len(labels)}")

# # Create a DataFrame with the selected columns
# df_final = pd.DataFrame({
#     'X1': X1,
#     'X2': X2,
#     'X3': X3,
#     'X4': X4,
#     'label': labels
# })

# # Display the first few rows to check the result
# print(df_final.head())

# # Save the formatted dataset to a new CSV file
# df_final.to_csv('Crânios Egípcios Formatado.csv', index=False)

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
df = pd.read_csv('Crânios Egípcios Formatado.csv')
data = np.array(df)
df.head()

print(f'O data freme contem: {df.shape[0]} linhas ')
print(f'O data freme contem: {df.shape[1]} coluns ')

# mediana dos valores de cada coluna

grouped = df.groupby(["label"]).median()
display(grouped)

# media  dos valores de cada coluna
grouped = df.groupby(["label"]).mean()
display(grouped)

# moda dos valores de cada coluna

def calcular_moda(serie):
    modas = serie.mode()
    return ', '.join(map(str, modas))

# Agrupando pelo período histórico (label) e calculando a moda para as colunas X1, X2, X3 e X4
moda_por_periodo = df.groupby('label').agg(calcular_moda)

# Exibindo o resultado
moda_por_periodo

# valores maximos e minimos e desvio padrão
def calcular_amplitude(serie):
    return serie.max() - serie.min()

amplitude = df.groupby('label').agg(['max', 'min', calcular_amplitude])
amplitude

#  desviu padrão e variancia dos dados
desvio_variancia_por_periodo = df.groupby('label').agg(['std', 'var'])

# Exibindo o resultado
desvio_variancia_por_periodo

lista_periodos=['Pré-dinástico primitivo','Pré-dinástico antigo', '12 e 13 dinastias',
     'Período ptolemaico','Período romano']
colunas = ['X1', 'X2', 'X3', 'X4']

# Loop para gerar um boxplot para cada variável
for coluna in colunas:
    plt.figure(figsize=(12, 8))  # Define o tamanho da figura
    sns.boxplot(x='label', y=coluna, data=df)
    plt.title(f'Boxplot de {coluna} por Período Histórico')
    plt.xticks(rotation=45)  # Rotaciona os rótulos do eixo X para melhor visualização
    plt.show()



colunas = ['X1', 'X2', 'X3', 'X4']

for coluna in colunas:
    g = sns.FacetGrid(df, col='label', col_wrap=4, height=4, aspect=1.5)  # Cria grid de gráficos, um por período histórico
    g.map(sns.histplot, coluna, bins=20, kde=False)  # Aplica o histograma para cada variável
    g.set_axis_labels(coluna, "Frequência")  # Define os rótulos dos eixos
    g.fig.suptitle(f'Histograma de {coluna} por Período Histórico', y=1.05)  # Título do gráfico
    plt.xticks(rotation=45)  # Rotaciona os rótulos do eixo X para melhor visualização
    plt.show()

import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt

# Lista de períodos históricos
lista_periodos = [
    'Pré-dinástico primitivo',
    'Pré-dinástico antigo',
    '12 e 13 dinastias',
    'Período ptolemaico',
    'Período romano'
]

# Agrupando o DataFrame por 'label'
grupo = df.groupby('label')

# Iterando sobre cada período na lista
for periodo in lista_periodos:
    # Obtendo o grupo correspondente ao período
    grupo_A = grupo.get_group(periodo)

    # Removendo a coluna 'label' para calcular a correlação apenas com os dados numéricos
    grupo_A = grupo_A.drop('label', axis=1)

    # Calculando a matriz de correlação
    correlation_matrix = grupo_A.corr()

    # Exibindo o nome do período e a matriz de correlação
    print(f'\n {periodo} \n')
    print(correlation_matrix)

    # Criando um gráfico de calor (heatmap) da matriz de correlação
    plt.figure()
    sns.heatmap(correlation_matrix, annot=True, cmap='coolwarm')
    plt.title(f'Matriz de Correlação: {periodo}')
    plt.xticks(rotation=90)
    plt.show()

from sklearn import tree
from sklearn.model_selection import train_test_split
from sklearn.tree import DecisionTreeClassifier
from sklearn.metrics import accuracy_score, classification_report
# clf = tree.DecisionTreeClassifier()

X = df.drop(columns='label')  # Colunas de características
y = df['label']  # Variável alvo

# Dividindo os dados em conjuntos de treino e teste (80% treino, 20% teste)
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

modelo_arvore = DecisionTreeClassifier(random_state=42)

# Treinando o modelo
modelo_arvore.fit(X_train, y_train)

# Fazendo previsões com os dados de teste
y_pred = modelo_arvore.predict(X_test)

# Avaliando o desempenho
acuracia = accuracy_score(y_test, y_pred)
relatorio_classificacao = classification_report(y_test, y_pred)

print(f'Acurácia: {acuracia}')
print(f'Relatório de Classificação:\n{relatorio_classificacao}')

import pandas as pd
import numpy as np

# Função para calcular a moda (a moda pode ter mais de um valor, então pegamos o primeiro)
def mode(series):
    return series.mode()[0] if not series.mode().empty else np.nan

# Calcula as métricas (max, min, mean, mode, std, var) para cada grupo (label)
grouped_max = df.groupby("label").max()
grouped_min = df.groupby("label").min()
grouped_mean = df.groupby("label").mean()
grouped_mode = df.groupby("label").agg(mode)
grouped_std = df.groupby("label").std()
grouped_var = df.groupby("label").var()

# Organizando os resultados em um novo DataFrame
metrics_df = pd.DataFrame()

# Para cada coluna (X1, X2, X3, X4), adicionar as métricas como colunas e organizar as colunas numéricas como linhas
for col in ['X1', 'X2', 'X3', 'X4']:
    metrics_df[col + '_max'] = grouped_max[col]
    metrics_df[col + '_min'] = grouped_min[col]
    metrics_df[col + '_mean'] = grouped_mean[col]
    metrics_df[col + '_mode'] = grouped_mode[col]
    metrics_df[col + '_std'] = grouped_std[col]
    metrics_df[col + '_var'] = grouped_var[col]

# Transpõe o DataFrame para que as colunas (X1, X2, etc.) fiquem como linhas
metrics_df = metrics_df.T

# Exibindo o DataFrame final
print(metrics_df)
display(metrics_df)

